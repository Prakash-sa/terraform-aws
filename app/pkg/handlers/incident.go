package handlers
package handlers

import (
	"encoding/json"
	"fmt"














































































































































































































































}	})		Timestamp: time.Now(),		Error:     message,	json.NewEncoder(w).Encode(APIResponse{	w.WriteHeader(statusCode)	w.Header().Set("Content-Type", "application/json")func respondError(w http.ResponseWriter, statusCode int, message string) {// respondError sends an error JSON response}	json.NewEncoder(w).Encode(data)	w.WriteHeader(statusCode)	w.Header().Set("Content-Type", "application/json")func respondJSON(w http.ResponseWriter, statusCode int, data interface{}) {// respondJSON sends a JSON response}	Timestamp time.Time   `json:"timestamp"`	Error     string      `json:"error,omitempty"`	Data      interface{} `json:"data,omitempty"`	Message   string      `json:"message,omitempty"`type APIResponse struct {// APIResponse represents a standard API response// Response helpers}	respondJSON(w, http.StatusOK, summary)	}		}			GeneratedAt: time.Now(),			Alerts:      []string{},			KeyInsights: []string{},			Summary:     fmt.Sprintf("Summarization failed: %v", err),		summary = &models.LogSummarizeResponse{		// Still return with error message		h.logger.Warn("log summarization encountered error but returning result", zap.Error(err))	if err != nil {	summary, err := h.incidentService.SummarizeLogs(req.Logs)	}		return		respondError(w, http.StatusBadRequest, "logs array is required")	if len(req.Logs) == 0 {	}		return		respondError(w, http.StatusBadRequest, "invalid request body")	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {	var req models.LogSummarizeRequestfunc (h *IncidentHandler) SummarizeLogs(w http.ResponseWriter, r *http.Request) {// SummarizeLogs handles POST /api/v1/logs/summarize}	respondJSON(w, http.StatusOK, incident)	}		return		respondJSON(w, http.StatusOK, response)		}			"error":    err.Error(),			"incident": incident,		response := map[string]interface{}{		// Still return the incident with error message		h.logger.Warn("RCA generation encountered error but returning result", zap.String("id", id), zap.Error(err))	if err != nil {	incident, err := h.incidentService.GenerateRCA(id)	id := mux.Vars(r)["id"]func (h *IncidentHandler) GenerateRCA(w http.ResponseWriter, r *http.Request) {// GenerateRCA handles POST /api/v1/incidents/{id}/rca/generate}	respondJSON(w, http.StatusOK, incident)	}		return		respondJSON(w, http.StatusOK, response)		}			"error":    err.Error(),			"incident": incident,		response := map[string]interface{}{		// Still return the incident with error message		h.logger.Warn("analysis encountered error but returning result", zap.String("id", id), zap.Error(err))	if err != nil {	incident, err := h.incidentService.AnalyzeIncident(id)	id := mux.Vars(r)["id"]func (h *IncidentHandler) AnalyzeIncident(w http.ResponseWriter, r *http.Request) {// AnalyzeIncident handles POST /api/v1/incidents/{id}/analyze}	w.WriteHeader(http.StatusNoContent)	}		return		respondError(w, http.StatusNotFound, err.Error())	if err != nil {	err := h.incidentService.DeleteIncident(id)	id := mux.Vars(r)["id"]func (h *IncidentHandler) DeleteIncident(w http.ResponseWriter, r *http.Request) {// DeleteIncident handles DELETE /api/v1/incidents/{id}}	respondJSON(w, http.StatusOK, incident)	}		return		}			respondError(w, http.StatusInternalServerError, "failed to update incident")			h.logger.Error("failed to update incident", zap.String("id", id), zap.Error(err))		} else {			respondError(w, http.StatusNotFound, err.Error())		if err.Error() == fmt.Sprintf("incident not found: %s", id) {	if err != nil {	incident, err := h.incidentService.UpdateIncident(id, &req)	}		return		respondError(w, http.StatusBadRequest, "invalid request body")	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {	var req models.UpdateIncidentRequest	id := mux.Vars(r)["id"]func (h *IncidentHandler) UpdateIncident(w http.ResponseWriter, r *http.Request) {// UpdateIncident handles PUT /api/v1/incidents/{id}}	respondJSON(w, http.StatusOK, incidents)	}		incidents = []*models.Incident{}	if incidents == nil {	}		return		respondError(w, http.StatusInternalServerError, "failed to list incidents")		h.logger.Error("failed to list incidents", zap.Error(err))	if err != nil {	incidents, err := h.incidentService.ListIncidents(statusFilter, severityFilter)	}		severityFilter = &severity		severity := models.Severity(severityParam)	if severityParam != "" {	}		statusFilter = &status		status := models.IncidentStatus(statusParam)	if statusParam != "" {	var severityFilter *models.Severity	var statusFilter *models.IncidentStatus	severityParam := r.URL.Query().Get("severity")	statusParam := r.URL.Query().Get("status")	// Optional query parameters for filteringfunc (h *IncidentHandler) ListIncidents(w http.ResponseWriter, r *http.Request) {// ListIncidents handles GET /api/v1/incidents}	respondJSON(w, http.StatusOK, incident)	}		return		respondError(w, http.StatusNotFound, fmt.Sprintf("incident not found: %s", id))	if err != nil {	incident, err := h.incidentService.GetIncident(id)		id := mux.Vars(r)["id"]func (h *IncidentHandler) GetIncident(w http.ResponseWriter, r *http.Request) {// GetIncident handles GET /api/v1/incidents/{id}}	respondJSON(w, http.StatusCreated, incident)	}		return		respondError(w, http.StatusInternalServerError, "failed to create incident")		h.logger.Error("failed to create incident", zap.Error(err))	if err != nil {	incident, err := h.incidentService.CreateIncident(&req)	}		return		respondError(w, http.StatusBadRequest, "title and description are required")	if req.Title == "" || req.Description == "" {	}		return		respondError(w, http.StatusBadRequest, "invalid request body")	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {	var req models.CreateIncidentRequestfunc (h *IncidentHandler) CreateIncident(w http.ResponseWriter, r *http.Request) {// CreateIncident handles POST /api/v1/incidents}	v1.HandleFunc("/logs/summarize", h.SummarizeLogs).Methods(http.MethodPost)	// Log endpoints		v1.HandleFunc("/incidents/{id}/rca/generate", h.GenerateRCA).Methods(http.MethodPost)	v1.HandleFunc("/incidents/{id}/analyze", h.AnalyzeIncident).Methods(http.MethodPost)	v1.HandleFunc("/incidents/{id}", h.DeleteIncident).Methods(http.MethodDelete)	v1.HandleFunc("/incidents/{id}", h.UpdateIncident).Methods(http.MethodPut)	v1.HandleFunc("/incidents/{id}", h.GetIncident).Methods(http.MethodGet)	v1.HandleFunc("/incidents", h.ListIncidents).Methods(http.MethodGet)	v1.HandleFunc("/incidents", h.CreateIncident).Methods(http.MethodPost)	// Incident endpoints		v1 := router.PathPrefix("/api/v1").Subrouter()func (h *IncidentHandler) RegisterRoutes(router *mux.Router) {// RegisterRoutes registers all incident routes}	}		logger:          logger,		incidentService: incidentService,	return &IncidentHandler{func NewIncidentHandler(incidentService *service.IncidentService, logger *zap.Logger) *IncidentHandler {// NewIncidentHandler creates a new incident handler}	logger          *zap.Logger	incidentService *service.IncidentServicetype IncidentHandler struct {// IncidentHandler handles incident-related HTTP requests)	"go.uber.org/zap"	"github.com/Prakash-sa/terraform-aws/app/pkg/service"	"github.com/Prakash-sa/terraform-aws/app/pkg/models"	"github.com/gorilla/mux"	"time"	"net/http"