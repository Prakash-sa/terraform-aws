package service
package service

import (
	"fmt"
	"sync"




























































































































































































































































































































































}	return timeline		}		timeline = append(timeline, fmt.Sprintf("Resolved: %s", incident.ResolvedAt.Format(time.RFC3339)))	if incident.ResolvedAt != nil {		}		fmt.Sprintf("Created: %s", incident.CreatedAt.Format(time.RFC3339)),	timeline := []string{func buildTimeline(incident *models.Incident) []string {}	return false	}		}			}				}					return true				if text[i:i+len(kw)] == kw {			for i := 0; i < len(text)-len(kw)+1; i++ {			t := text			// Case-insensitive search		if len(text) > 0 && len(kw) > 0 {	for _, kw := range keywords {func hasKeyword(text string, keywords ...string) bool {// Utility functions}	return &models.Incident{}	// This is a workaround - in production, use proper context.Contextfunc (s *IncidentService) createContext() *models.Incident {}	return models.SeverityLow		}		return models.SeverityMedium	if hasKeyword(desc, "warning", "degraded", "slow", "high memory") {	}		return models.SeverityHigh	if hasKeyword(desc, "error", "failure", "down", "unavailable") {	}		return models.SeverityCritical	if hasKeyword(desc, "critical", "production down", "data loss", "security breach") {		desc := incident.Description + " " + incident.Title	// Basic heuristics for severity classificationfunc (s *IncidentService) classifySeverity(incident *models.Incident) models.Severity {}	return fmt.Sprintf("INC-%d-%d", time.Now().Unix(), s.store.counter)	s.store.counter++	defer s.store.mu.Unlock()	s.store.mu.Lock()func (s *IncidentService) generateID() string {// Private helper methods}	}, nil		GeneratedAt: time.Now(),		Alerts:      summary.Alerts,		KeyInsights: summary.KeyInsights,		Summary:     summary.Summary,	return &models.LogSummarizeResponse{	}		return nil, err		s.logger.Error("failed to summarize logs", zap.Error(err))	if err != nil {	summary, err := s.aiClient.SummarizeLogs(s.createContext(), summarizeReq)	}		Logs: logs,	summarizeReq := ai.SummarizeRequest{func (s *IncidentService) SummarizeLogs(logs []string) (*models.LogSummarizeResponse, error) {// SummarizeLogs extracts insights from log collections}	return incident, nil	s.logger.Info("RCA generated", zap.String("id", id), zap.String("provider", string(s.aiClient.Provider())))	s.store.mu.Unlock()	incident.UpdatedAt = time.Now()	}		Provider:           string(s.aiClient.Provider()),		Model:              s.aiClient.Model(),		GeneratedAt:        time.Now(),		LessonsLearned:     rca.LessonsLearned,		PreventiveMeasures: rca.PreventiveMeasures,		ImmediateResolution: rca.ImmediateResolution,		Impact:             rca.Impact,		RootCause:          rca.RootCause,		Timeline:           rca.Timeline,	incident.RCADocument = &models.RCADocument{	s.store.mu.Lock()	// Convert AI response to model	}		return incident, err		s.logger.Error("failed to generate RCA", zap.String("id", id), zap.Error(err))	if err != nil {	rca, err := s.aiClient.GenerateRCA(s.createContext(), rcaReq)	}		Timeline:      buildTimeline(incident),		Analysis:      analysis,		IncidentDesc:  incident.Description,		IncidentTitle: incident.Title,	rcaReq := ai.RCARequest{	}		}			SuggestedSeverity:  string(incident.AIAnalysis.SeveritySuggestion),			RecommendedActions: incident.AIAnalysis.RecommendedActions,			RootCauses:         incident.AIAnalysis.RootCauses,			Findings:           incident.AIAnalysis.Findings,			Summary:            incident.AIAnalysis.Summary,		analysis = ai.AnalysisResponse{	if incident.AIAnalysis != nil {	var analysis ai.AnalysisResponse	// Use existing analysis or create empty one	}		return nil, err	if err != nil {	incident, err := s.GetIncident(id)func (s *IncidentService) GenerateRCA(id string) (*models.Incident, error) {// GenerateRCA generates a root cause analysis document}	return incident, nil	s.logger.Info("incident analyzed", zap.String("id", id), zap.String("provider", string(s.aiClient.Provider())))	s.store.mu.Unlock()	incident.UpdatedAt = time.Now()	}		Provider:           string(s.aiClient.Provider()),		Model:              s.aiClient.Model(),		GeneratedAt:        time.Now(),		SeveritySuggestion: models.Severity(analysis.SuggestedSeverity),		RecommendedActions: analysis.RecommendedActions,		RootCauses:         analysis.RootCauses,		Findings:           analysis.Findings,		Summary:            analysis.Summary,	incident.AIAnalysis = &models.AIAnalysis{	s.store.mu.Lock()	// Convert AI response to model	}		return incident, err		s.logger.Error("failed to analyze incident", zap.String("id", id), zap.Error(err))	if err != nil {	analysis, err := s.aiClient.AnalyzeIncident(s.createContext(), analysisReq)	}		Logs:          incident.Logs,		IncidentDesc:  incident.Description,		IncidentTitle: incident.Title,	analysisReq := ai.AnalysisRequest{	// Call AI client to analyze	}		return nil, err	if err != nil {	incident, err := s.GetIncident(id)func (s *IncidentService) AnalyzeIncident(id string) (*models.Incident, error) {// AnalyzeIncident generates AI analysis for an incident}	return nil	s.logger.Info("incident deleted", zap.String("id", id))	s.store.mu.Unlock()	delete(s.store.incidents, id)	}		return fmt.Errorf("incident not found: %s", id)		s.store.mu.Unlock()	if _, ok := s.store.incidents[id]; !ok {	s.store.mu.Lock()func (s *IncidentService) DeleteIncident(id string) error {// DeleteIncident deletes an incident}	return incident, nil	s.logger.Info("incident updated", zap.String("id", incident.ID))	incident.UpdatedAt = time.Now()	}		incident.AssignedTo = *req.AssignedTo	if req.AssignedTo != nil {	}		incident.Metadata = req.Metadata	if req.Metadata != nil {	}		incident.Tags = req.Tags	if len(req.Tags) > 0 {	}		incident.Logs = req.Logs	if len(req.Logs) > 0 {	}		}			incident.ResolvedAt = &now			now := time.Now()		if *req.Status == models.StatusResolved && oldStatus != models.StatusResolved {		// Set resolved time when status changes to resolved				incident.Status = *req.Status		oldStatus := incident.Status	if req.Status != nil {	}		incident.Severity = *req.Severity	if req.Severity != nil {	}		incident.Description = *req.Description	if req.Description != nil {	}		incident.Title = *req.Title	if req.Title != nil {	defer s.store.mu.Unlock()	s.store.mu.Lock()	}		return nil, fmt.Errorf("incident not found: %s", id)	if !ok {	s.store.mu.Unlock()	incident, ok := s.store.incidents[id]	s.store.mu.Lock()func (s *IncidentService) UpdateIncident(id string, req *models.UpdateIncidentRequest) (*models.Incident, error) {// UpdateIncident updates an existing incident}	return results, nil	}		results = append(results, incident)		}			continue		if filterSeverity != nil && incident.Severity != *filterSeverity {		}			continue		if filterStatus != nil && incident.Status != *filterStatus {	for _, incident := range s.store.incidents {	var results []*models.Incident	defer s.store.mu.RUnlock()	s.store.mu.RLock()func (s *IncidentService) ListIncidents(filterStatus *models.IncidentStatus, filterSeverity *models.Severity) ([]*models.Incident, error) {// ListIncidents returns all incidents with optional filtering}	return incident, nil	}		return nil, fmt.Errorf("incident not found: %s", id)	if !ok {	s.store.mu.RUnlock()	incident, ok := s.store.incidents[id]	s.store.mu.RLock()func (s *IncidentService) GetIncident(id string) (*models.Incident, error) {// GetIncident retrieves an incident by ID}	return incident, nil	s.logger.Info("incident created", zap.String("id", incident.ID), zap.String("title", incident.Title))	s.store.mu.Unlock()	s.store.incidents[incident.ID] = incident	s.store.mu.Lock()	// Store the incident	}		incident.Metadata = make(map[string]interface{})	if incident.Metadata == nil {	}		incident.Severity = severity		severity := s.classifySeverity(incident)		// Try to classify severity using AI	} else {		incident.Severity = *req.Severity	if req.Severity != nil {	// Use provided severity or classify with AI	}		UpdatedAt:   time.Now(),		CreatedAt:   time.Now(),		AssignedTo:  req.AssignedTo,		Metadata:    req.Metadata,		Tags:        req.Tags,		Logs:        req.Logs,		Status:      models.StatusOpen,		Source:      req.Source,		Description: req.Description,		Title:       req.Title,		ID:          s.generateID(),	incident := &models.Incident{func (s *IncidentService) CreateIncident(req *models.CreateIncidentRequest) (*models.Incident, error) {// CreateIncident creates a new incident with optional AI severity classification}	}		logger:   logger,		aiClient: aiClient,		store:    store,	return &IncidentService{func NewIncidentService(store *IncidentStore, aiClient ai.Client, logger *zap.Logger) *IncidentService {// NewIncidentService creates a new incident service}	}		counter:   0,		incidents: make(map[string]*models.Incident),	return &IncidentStore{func NewIncidentStore() *IncidentStore {// NewIncidentStore creates a new incident store}	logger  *zap.Logger	aiClient ai.Client	store   *IncidentStoretype IncidentService struct {// IncidentService provides business logic for incident management}	counter   int64	incidents map[string]*models.Incident	mu        sync.RWMutextype IncidentStore struct {// IncidentStore provides thread-safe incident storage and retrieval)	"go.uber.org/zap"	"github.com/Prakash-sa/terraform-aws/app/pkg/models"	"github.com/Prakash-sa/terraform-aws/app/pkg/ai"	"time"