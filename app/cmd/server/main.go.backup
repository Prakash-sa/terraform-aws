package server
package main

import (
	"context"
	"encoding/json"
	"fmt"




























































































































































































































































































}	logger.Info("Server stopped")	}		logger.Fatal("Server failed to start", zap.Error(err))	if err := server.Start(); err != nil && err != http.ErrServerClosed {	logger.Info("Server starting...")	}()		}			logger.Fatal("Server shutdown failed", zap.Error(err))		if err := server.Shutdown(ctx); err != nil {		defer cancel()		ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)		<-sigChan		signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)		sigChan := make(chan os.Signal, 1)	go func() {	// Graceful shutdown	server := NewServer()	defer logger.Sync()func main() {}	return defaultValue	}		return value	if value := os.Getenv(key); value != "" {func getEnv(key, defaultValue string) string {}	respondJSON(w, status, response)	}		Timestamp: time.Now(),		Message:   message,	response := APIResponse{func respondError(w http.ResponseWriter, status int, message string) {}	}		logger.Error("Failed to encode JSON response", zap.Error(err))	if err := json.NewEncoder(w).Encode(payload); err != nil {	w.WriteHeader(status)	w.Header().Set("Content-Type", "application/json")func respondJSON(w http.ResponseWriter, status int, payload interface{}) {// Helper functions}	respondJSON(w, http.StatusOK, response)	}		Timestamp: time.Now(),		Data:      payload,		Message:   "Echo response",	response := APIResponse{	}		return		respondError(w, http.StatusBadRequest, "Invalid JSON payload")	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {	var payload map[string]interface{}func echoHandler(w http.ResponseWriter, r *http.Request) {}	respondJSON(w, http.StatusOK, response)	}		Timestamp: time.Now(),		Data:      data,		Message:   "Data retrieved successfully",	response := APIResponse{	}		"total": 3,		},			{"id": 3, "name": "Item 3", "price": 199.99},			{"id": 2, "name": "Item 2", "price": 149.99},			{"id": 1, "name": "Item 1", "price": 99.99},		"items": []map[string]interface{}{	data := map[string]interface{}{	// Simulate data retrievalfunc dataHandler(w http.ResponseWriter, r *http.Request) {}	respondJSON(w, http.StatusOK, response)	}		},			"cache":    "ok",			"database": "ok",		"checks": map[string]string{		"timestamp": time.Now(),		"ready":     true,	response := map[string]interface{}{	// For now, we'll just return ready	// Add your readiness checks here (database, cache, etc.)func readinessHandler(w http.ResponseWriter, r *http.Request) {}	respondJSON(w, http.StatusOK, response)	}		Uptime:    time.Since(startTime).String(),		Version:   getEnv("APP_VERSION", "1.0.0"),		Timestamp: time.Now(),		Status:    "healthy",	response := HealthResponse{func healthHandler(w http.ResponseWriter, r *http.Request) {}	respondJSON(w, http.StatusOK, response)	}		},			"environment": getEnv("ENVIRONMENT", "production"),			"version":     getEnv("APP_VERSION", "1.0.0"),		Data: map[string]string{		Timestamp: time.Now(),		Message:   "Welcome to the Production-Ready Go API",	response := APIResponse{func homeHandler(w http.ResponseWriter, r *http.Request) {// Handlers}	rw.ResponseWriter.WriteHeader(code)	rw.statusCode = codefunc (rw *responseWriter) WriteHeader(code int) {}	statusCode int	http.ResponseWritertype responseWriter struct {}	})		httpRequestsTotal.WithLabelValues(r.Method, path, fmt.Sprintf("%d", wrapped.statusCode)).Inc()		httpRequestDuration.WithLabelValues(r.Method, path).Observe(duration)		duration := time.Since(start).Seconds()		next.ServeHTTP(wrapped, r)		wrapped := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}		// Wrap response writer to capture status code		path, _ := route.GetPathTemplate()		route := mux.CurrentRoute(r)		start := time.Now()	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {func metricsMiddleware(next http.Handler) http.Handler {}	})		)			zap.Duration("duration", time.Since(start)),			zap.String("path", r.URL.Path),			zap.String("method", r.Method),		logger.Info("Request completed",		next.ServeHTTP(w, r)		)			zap.String("remote_addr", r.RemoteAddr),			zap.String("path", r.URL.Path),			zap.String("method", r.Method),		logger.Info("Request received",		defer activeConnections.Dec()		activeConnections.Inc()		start := time.Now()	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {func loggingMiddleware(next http.Handler) http.Handler {// Middleware}	return s.server.Shutdown(ctx)	logger.Info("Shutting down server gracefully...")func (s *Server) Shutdown(ctx context.Context) error {}	return s.server.ListenAndServe()	)		zap.Time("start_time", startTime),		zap.String("port", s.server.Addr),	logger.Info("Starting server",func (s *Server) Start() error {}	return s	}		IdleTimeout:  60 * time.Second,		WriteTimeout: 15 * time.Second,		ReadTimeout:  15 * time.Second,		Handler:      s.router,		Addr:         ":" + port,	s.server = &http.Server{	port := getEnv("PORT", "8080")	s.router.Handle("/metrics", promhttp.Handler()).Methods("GET")	s.router.HandleFunc("/api/v1/echo", echoHandler).Methods("POST")	s.router.HandleFunc("/api/v1/data", dataHandler).Methods("GET")	s.router.HandleFunc("/ready", readinessHandler).Methods("GET")	s.router.HandleFunc("/health", healthHandler).Methods("GET")	s.router.HandleFunc("/", homeHandler).Methods("GET")	// Routes	s.router.Use(metricsMiddleware)	s.router.Use(loggingMiddleware)	// Middleware	}		router: mux.NewRouter(),	s := &Server{func NewServer() *Server {}	}		panic(fmt.Sprintf("Failed to initialize logger: %v", err))	if err != nil {	logger, err = zap.NewProduction()	var err errorfunc init() {var startTime = time.Now()}	Timestamp time.Time   `json:"timestamp"`	Data      interface{} `json:"data,omitempty"`	Message   string      `json:"message"`type APIResponse struct {}	Uptime    string    `json:"uptime"`	Version   string    `json:"version"`	Timestamp time.Time `json:"timestamp"`	Status    string    `json:"status"`type HealthResponse struct {}	server *http.Server	router *mux.Routertype Server struct {)	logger *zap.Logger	)		},			Help: "Number of active connections",			Name: "active_connections",		prometheus.GaugeOpts{	activeConnections = promauto.NewGauge(	)		[]string{"method", "endpoint"},		},			Buckets: prometheus.DefBuckets,			Help:    "Duration of HTTP requests in seconds",			Name:    "http_request_duration_seconds",		prometheus.HistogramOpts{	httpRequestDuration = promauto.NewHistogramVec(	)		[]string{"method", "endpoint", "status"},		},			Help: "Total number of HTTP requests",			Name: "http_requests_total",		prometheus.CounterOpts{	httpRequestsTotal = promauto.NewCounterVec(	// Prometheus metricsvar ()	"go.uber.org/zap"	"github.com/prometheus/client_golang/prometheus/promhttp"	"github.com/prometheus/client_golang/prometheus/promauto"	"github.com/prometheus/client_golang/prometheus"	"github.com/gorilla/mux"	"time"	"syscall"	"os/signal"	"os"	"net/http"